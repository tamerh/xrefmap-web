// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file xref.colf for package xref_colf/xref_colf.


var xref_colf = new function() {
    const EOF = 'colfer: EOF';

    // The upper limit for serial byte sizes.
    var colferSizeMax = 16 * 1024 * 1024;
    // The upper limit for the number of elements in a list.
    var colferListMax = 64 * 1024;

    // Constructor.

    // When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
    this.XrefEntry = function(init) {

        this.domain_id = 0;

        this.xref_id = '';

        for (var p in init) this[p] = init[p];
    }

    // Serializes the object into an Uint8Array.
    this.XrefEntry.prototype.marshal = function(buf) {
        if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
        var i = 0;
        var view = new DataView(buf.buffer);


        if (this.domain_id) {
            if (this.domain_id > 255 || this.domain_id < 0)
                throw new Error('colfer: xref_colf/XrefEntry field domain_id out of reach: ' + this.domain_id);
            buf[i++] = 0;
            buf[i++] = this.domain_id;
        }

        if (this.xref_id) {
            buf[i++] = 1;
            var utf8 = encodeUTF8(this.xref_id);
            i = encodeVarint(buf, i, utf8.length);
            buf.set(utf8, i);
            i += utf8.length;
        }


        buf[i++] = 127;
        if (i >= colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.XrefEntry serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
        return buf.subarray(0, i);
    }

    // Deserializes the object from an Uint8Array and returns the number of bytes read.
    this.XrefEntry.prototype.unmarshal = function(data) {
        if (!data || ! data.length) throw new Error(EOF);
        var header = data[0];
        var i = 1;
        var readHeader = function() {
            if (i >= data.length) throw new Error(EOF);
            header = data[i++];
        }

        var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

        var readVarint = function() {
            var pos = 0, result = 0;
            while (pos != 8) {
                var c = data[i+pos];
                result += (c & 127) * Math.pow(128, pos);
                ++pos;
                if (c < 128) {
                    i += pos;
                    if (result > Number.MAX_SAFE_INTEGER) break;
                    return result;
                }
                if (pos == data.length) throw new Error(EOF);
            }
            return -1;
        }

        if (header == 0) {
            if (i + 1 >= data.length) throw new Error(EOF);
            this.domain_id = data[i++];
            header = data[i++];
        }

        if (header == 1) {
            var size = readVarint();
            if (size < 0)
                throw new Error('colfer: xref_colf/xref_colf.XrefEntry.xref_id size exceeds Number.MAX_SAFE_INTEGER');
            else if (size > colferSizeMax)
                throw new Error('colfer: xref_colf/xref_colf.XrefEntry.xref_id size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

            var start = i;
            i += size;
            if (i > data.length) throw new Error(EOF);
            this.xref_id = decodeUTF8(data.subarray(start, i));
            readHeader();
        }

        if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
        if (i > colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.XrefEntry serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
        return i;
    }

    // Constructor.

    // When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
    this.XrefDomainCount = function(init) {

        this.domain_id = 0;

        this.count = 0;
        
        for (var p in init) this[p] = init[p];
    }

    // Serializes the object into an Uint8Array.
    this.XrefDomainCount.prototype.marshal = function(buf) {
        if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
        var i = 0;
        var view = new DataView(buf.buffer);


        if (this.domain_id) {
            if (this.domain_id > 255 || this.domain_id < 0)
                throw new Error('colfer: xref_colf/XrefDomainCount field domain_id out of reach: ' + this.domain_id);
            buf[i++] = 0;
            buf[i++] = this.domain_id;
        }

        if (this.count) {
            if (this.count > 4294967295 || this.count < 0)
                throw new Error('colfer: xref_colf/XrefDomainCount field count out of reach: ' + this.count);
            if (this.count < 0x200000) {
                buf[i++] = 1;
                i = encodeVarint(buf, i, this.count);
            } else {
                buf[i++] = 1 | 128;
                view.setUint32(i, this.count);
                i += 4;
            }
        }


        buf[i++] = 127;
        if (i >= colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.XrefDomainCount serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
        return buf.subarray(0, i);
    }

    // Deserializes the object from an Uint8Array and returns the number of bytes read.
    this.XrefDomainCount.prototype.unmarshal = function(data) {
        if (!data || ! data.length) throw new Error(EOF);
        var header = data[0];
        var i = 1;
        var readHeader = function() {
            if (i >= data.length) throw new Error(EOF);
            header = data[i++];
        }

        var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

        var readVarint = function() {
            var pos = 0, result = 0;
            while (pos != 8) {
                var c = data[i+pos];
                result += (c & 127) * Math.pow(128, pos);
                ++pos;
                if (c < 128) {
                    i += pos;
                    if (result > Number.MAX_SAFE_INTEGER) break;
                    return result;
                }
                if (pos == data.length) throw new Error(EOF);
            }
            return -1;
        }

        if (header == 0) {
            if (i + 1 >= data.length) throw new Error(EOF);
            this.domain_id = data[i++];
            header = data[i++];
        }

        if (header == 1) {
            var x = readVarint();
            if (x < 0) throw new Error('colfer: xref_colf/XrefDomainCount field count exceeds Number.MAX_SAFE_INTEGER');
            this.count = x;
            readHeader();
        } else if (header == (1 | 128)) {
            if (i + 4 > data.length) throw new Error(EOF);
            this.count = view.getUint32(i);
            i += 4;
            readHeader();
        }

        if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
        if (i > colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.XrefDomainCount serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
        return i;
    }

    // Constructor.

    // When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
    this.Xref = function(init) {

        this.domain_id = 0;

        this.count = 0;

        this.domain_counts = [];

        this.entries = [];

        for (var p in init) this[p] = init[p];
    }

    // Serializes the object into an Uint8Array.
    // All null entries in property domain_counts will be replaced with a new xref_colf.XrefDomainCount.
    // All null entries in property entries will be replaced with a new xref_colf.XrefEntry.
    this.Xref.prototype.marshal = function(buf) {
        if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
        var i = 0;
        var view = new DataView(buf.buffer);


        if (this.domain_id) {
            if (this.domain_id > 255 || this.domain_id < 0)
                throw new Error('colfer: xref_colf/Xref field domain_id out of reach: ' + this.domain_id);
            buf[i++] = 0;
            buf[i++] = this.domain_id;
        }

        if (this.count) {
            if (this.count > 4294967295 || this.count < 0)
                throw new Error('colfer: xref_colf/Xref field count out of reach: ' + this.count);
            if (this.count < 0x200000) {
                buf[i++] = 1;
                i = encodeVarint(buf, i, this.count);
            } else {
                buf[i++] = 1 | 128;
                view.setUint32(i, this.count);
                i += 4;
            }
        }

        if (this.domain_counts && this.domain_counts.length) {
            var a = this.domain_counts;
            if (a.length > colferListMax)
                throw new Error('colfer: xref_colf/xref_colf.Xref.domain_counts length exceeds colferListMax');
            buf[i++] = 2;
            i = encodeVarint(buf, i, a.length);
            a.forEach(function(v, vi) {
                if (v == null) {
                    v = new xref_colf.XrefDomainCount();
                    a[vi] = v;
                }
                var b = v.marshal();
                buf.set(b, i);
                i += b.length;
            });
        }

        if (this.entries && this.entries.length) {
            var a = this.entries;
            if (a.length > colferListMax)
                throw new Error('colfer: xref_colf/xref_colf.Xref.entries length exceeds colferListMax');
            buf[i++] = 3;
            i = encodeVarint(buf, i, a.length);
            a.forEach(function(v, vi) {
                if (v == null) {
                    v = new xref_colf.XrefEntry();
                    a[vi] = v;
                }
                var b = v.marshal();
                buf.set(b, i);
                i += b.length;
            });
        }


        buf[i++] = 127;
        if (i >= colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.Xref serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
        return buf.subarray(0, i);
    }

    // Deserializes the object from an Uint8Array and returns the number of bytes read.
    this.Xref.prototype.unmarshal = function(data) {
        if (!data || ! data.length) throw new Error(EOF);
        var header = data[0];
        var i = 1;
        var readHeader = function() {
            if (i >= data.length) throw new Error(EOF);
            header = data[i++];
        }

        var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

        var readVarint = function() {
            var pos = 0, result = 0;
            while (pos != 8) {
                var c = data[i+pos];
                result += (c & 127) * Math.pow(128, pos);
                ++pos;
                if (c < 128) {
                    i += pos;
                    if (result > Number.MAX_SAFE_INTEGER) break;
                    return result;
                }
                if (pos == data.length) throw new Error(EOF);
            }
            return -1;
        }

        if (header == 0) {
            if (i + 1 >= data.length) throw new Error(EOF);
            this.domain_id = data[i++];
            header = data[i++];
        }

        if (header == 1) {
            var x = readVarint();
            if (x < 0) throw new Error('colfer: xref_colf/Xref field count exceeds Number.MAX_SAFE_INTEGER');
            this.count = x;
            readHeader();
        } else if (header == (1 | 128)) {
            if (i + 4 > data.length) throw new Error(EOF);
            this.count = view.getUint32(i);
            i += 4;
            readHeader();
        }

        if (header == 2) {
            var l = readVarint();
            if (l < 0) throw new Error('colfer: xref_colf/xref_colf.Xref.domain_counts length exceeds Number.MAX_SAFE_INTEGER');
            if (l > colferListMax)
                throw new Error('colfer: xref_colf/xref_colf.Xref.domain_counts length ' + l + ' exceeds ' + colferListMax + ' elements');

            for (var n = 0; n < l; ++n) {
                var o = new xref_colf.XrefDomainCount();
                i += o.unmarshal(data.subarray(i));
                this.domain_counts[n] = o;
            }
            readHeader();
        }

        if (header == 3) {
            var l = readVarint();
            if (l < 0) throw new Error('colfer: xref_colf/xref_colf.Xref.entries length exceeds Number.MAX_SAFE_INTEGER');
            if (l > colferListMax)
                throw new Error('colfer: xref_colf/xref_colf.Xref.entries length ' + l + ' exceeds ' + colferListMax + ' elements');

            for (var n = 0; n < l; ++n) {
                var o = new xref_colf.XrefEntry();
                i += o.unmarshal(data.subarray(i));
                this.entries[n] = o;
            }
            readHeader();
        }

        if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
        if (i > colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.Xref serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
        return i;
    }

    // Constructor.

    // When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
    this.Result = function(init) {

        this.identifier = '';

        this.results = [];

        for (var p in init) this[p] = init[p];
    }

    // Serializes the object into an Uint8Array.
    // All null entries in property results will be replaced with a new xref_colf.Xref.
    this.Result.prototype.marshal = function(buf) {
        if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
        var i = 0;
        var view = new DataView(buf.buffer);


        if (this.identifier) {
            buf[i++] = 0;
            var utf8 = encodeUTF8(this.identifier);
            i = encodeVarint(buf, i, utf8.length);
            buf.set(utf8, i);
            i += utf8.length;
        }

        if (this.results && this.results.length) {
            var a = this.results;
            if (a.length > colferListMax)
                throw new Error('colfer: xref_colf/xref_colf.Result.results length exceeds colferListMax');
            buf[i++] = 1;
            i = encodeVarint(buf, i, a.length);
            a.forEach(function(v, vi) {
                if (v == null) {
                    v = new xref_colf.Xref();
                    a[vi] = v;
                }
                var b = v.marshal();
                buf.set(b, i);
                i += b.length;
            });
        }


        buf[i++] = 127;
        if (i >= colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.Result serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
        return buf.subarray(0, i);
    }

    // Deserializes the object from an Uint8Array and returns the number of bytes read.
    this.Result.prototype.unmarshal = function(data) {
        if (!data || ! data.length) throw new Error(EOF);
        var header = data[0];
        var i = 1;
        var readHeader = function() {
            if (i >= data.length) throw new Error(EOF);
            header = data[i++];
        }

        var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

        var readVarint = function() {
            var pos = 0, result = 0;
            while (pos != 8) {
                var c = data[i+pos];
                result += (c & 127) * Math.pow(128, pos);
                ++pos;
                if (c < 128) {
                    i += pos;
                    if (result > Number.MAX_SAFE_INTEGER) break;
                    return result;
                }
                if (pos == data.length) throw new Error(EOF);
            }
            return -1;
        }

        if (header == 0) {
            var size = readVarint();
            if (size < 0)
                throw new Error('colfer: xref_colf/xref_colf.Result.identifier size exceeds Number.MAX_SAFE_INTEGER');
            else if (size > colferSizeMax)
                throw new Error('colfer: xref_colf/xref_colf.Result.identifier size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

            var start = i;
            i += size;
            if (i > data.length) throw new Error(EOF);
            this.identifier = decodeUTF8(data.subarray(start, i));
            readHeader();
        }

        if (header == 1) {
            var l = readVarint();
            if (l < 0) throw new Error('colfer: xref_colf/xref_colf.Result.results length exceeds Number.MAX_SAFE_INTEGER');
            if (l > colferListMax)
                throw new Error('colfer: xref_colf/xref_colf.Result.results length ' + l + ' exceeds ' + colferListMax + ' elements');

            for (var n = 0; n < l; ++n) {
                var o = new xref_colf.Xref();
                i += o.unmarshal(data.subarray(i));
                this.results[n] = o;
            }
            readHeader();
        }

        if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
        if (i > colferSizeMax)
            throw new Error('colfer: xref_colf/xref_colf.Result serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
        return i;
    }

    // private section

    var encodeVarint = function(bytes, i, x) {
        while (x > 127) {
            bytes[i++] = (x & 127) | 128;
            x /= 128;
        }
        bytes[i++] = x & 127;
        return i;
    }

    function encodeUTF8(s) {
        var i = 0, bytes = new Uint8Array(s.length * 4);
        for (var ci = 0; ci != s.length; ci++) {
            var c = s.charCodeAt(ci);
            if (c < 128) {
                bytes[i++] = c;
                continue;
            }
            if (c < 2048) {
                bytes[i++] = c >> 6 | 192;
            } else {
                if (c > 0xd7ff && c < 0xdc00) {
                    if (++ci >= s.length) {
                        bytes[i++] = 63;
                        continue;
                    }
                    var c2 = s.charCodeAt(ci);
                    if (c2 < 0xdc00 || c2 > 0xdfff) {
                        bytes[i++] = 63;
                        --ci;
                        continue;
                    }
                    c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
                    bytes[i++] = c >> 18 | 240;
                    bytes[i++] = c >> 12 & 63 | 128;
                } else bytes[i++] = c >> 12 | 224;
                bytes[i++] = c >> 6 & 63 | 128;
            }
            bytes[i++] = c & 63 | 128;
        }
        return bytes.subarray(0, i);
    }

    function decodeUTF8(bytes) {
        var i = 0, s = '';
        while (i < bytes.length) {
            var c = bytes[i++];
            if (c > 127) {
                if (c > 191 && c < 224) {
                    c = (i >= bytes.length) ? 63 : (c & 31) << 6 | bytes[i++] & 63;
                } else if (c > 223 && c < 240) {
                    c = (i + 1 >= bytes.length) ? 63 : (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
                } else if (c > 239 && c < 248) {
                    c = (i + 2 >= bytes.length) ? 63 : (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
                } else c = 63
            }

            if (c <= 0xffff) s += String.fromCharCode(c);
            else if (c > 0x10ffff) s += '?';
            else {
                c -= 0x10000;
                s += String.fromCharCode(c >> 10 | 0xd800)
                s += String.fromCharCode(c & 0x3FF | 0xdc00)
            }
        }
        return s;
    }
}

export default xref_colf;
